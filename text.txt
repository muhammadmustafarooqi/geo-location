C:\Users\WEB PC\Desktop\web dev mustafa\geo-location\package.json

{
  "name": "geo-location",
  "private": true,
  "scripts": {
    "build": "remix vite:build",
    "dev": "shopify app dev",
    "config:link": "shopify app config link",
    "generate": "shopify app generate",
    "deploy": "shopify app deploy",
    "config:use": "shopify app config use",
    "env": "shopify app env",
    "start": "remix-serve ./build/server/index.js",
    "docker-start": "npm run setup && npm run start",
    "setup": "prisma generate && prisma migrate deploy",
    "lint": "eslint --cache --cache-location ./node_modules/.cache/eslint .",
    "shopify": "shopify",
    "prisma": "prisma",
    "graphql-codegen": "graphql-codegen",
    "vite": "vite"
  },
  "type": "module",
  "engines": {
    "node": "^18.20 || ^20.10 || >=21.0.0"
  },
  "dependencies": {
    "@prisma/client": "^6.2.1",
    "@remix-run/dev": "^2.16.1",
    "@remix-run/fs-routes": "^2.16.1",
    "@remix-run/node": "^2.16.1",
    "@remix-run/react": "^2.16.1",
    "@remix-run/serve": "^2.16.1",
    "@shopify/app-bridge-react": "^4.1.6",
    "@shopify/polaris": "^12.0.0",
    "@shopify/shopify-app-remix": "^3.7.0",
    "@shopify/shopify-app-session-storage-prisma": "^6.0.0",
    "isbot": "^5.1.0",
    "nodemailer": "^7.0.6",
    "prisma": "^6.2.1",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "vite-tsconfig-paths": "^5.0.1"
  },
  "devDependencies": {
    "@remix-run/eslint-config": "^2.16.1",
    "@remix-run/route-config": "^2.16.1",
    "@shopify/api-codegen-preset": "^1.1.1",
    "@types/eslint": "^9.6.1",
    "@types/node": "^22.2.0",
    "@types/react": "^18.2.31",
    "@types/react-dom": "^18.2.14",
    "eslint": "^8.42.0",
    "eslint-config-prettier": "^10.0.1",
    "prettier": "^3.2.4",
    "typescript": "^5.2.2",
    "vite": "^6.2.2"
  },
  "workspaces": [
    "extensions/*"
  ],
  "trustedDependencies": [
    "@shopify/plugin-cloudflare"
  ],
  "resolutions": {
    "@graphql-tools/url-loader": "8.0.16",
    "@graphql-codegen/client-preset": "4.7.0",
    "@graphql-codegen/typescript-operations": "4.5.0",
    "minimatch": "9.0.5",
    "vite": "^6.2.2"
  },
  "overrides": {
    "@graphql-tools/url-loader": "8.0.16",
    "@graphql-codegen/client-preset": "4.7.0",
    "@graphql-codegen/typescript-operations": "4.5.0",
    "minimatch": "9.0.5",
    "vite": "^6.2.2"
  },
  "author": "WEB PC"
}


C:\Users\WEB PC\Desktop\web dev mustafa\geo-location\shopify.app.toml
# Learn more about configuring your app at https://shopify.dev/docs/apps/tools/cli/configuration

client_id = "9e066822aa12172ceadeaa78e446a1b1"
name = "geo-location\r"
application_url = "https://el-hose-tag-intention.trycloudflare.com"
embedded = true
handle = "geo-location-6"

[build]
include_config_on_deploy = true
automatically_update_urls_on_dev = true

[webhooks]
api_version = "2025-07"

  [[webhooks.subscriptions]]
  topics = [ "app/uninstalled" ]
  uri = "/webhooks/app/uninstalled"

  [[webhooks.subscriptions]]
  topics = [ "app/scopes_update" ]
  uri = "/webhooks/app/scopes_update"

[access_scopes]
# Learn more at https://shopify.dev/docs/apps/tools/cli/configuration#access_scopes
scopes = "write_products"

[auth]
redirect_urls = ["https://el-hose-tag-intention.trycloudflare.com/auth/callback", "https://el-hose-tag-intention.trycloudflare.com/auth/shopify/callback", "https://el-hose-tag-intention.trycloudflare.com/api/auth/callback"]

[pos]
embedded = false


C:\Users\WEB PC\Desktop\web dev mustafa\geo-location\app\routes.js
import { flatRoutes } from "@remix-run/fs-routes";

export default flatRoutes();


C:\Users\WEB PC\Desktop\web dev mustafa\geo-location\app\entry.server.jsx
import { PassThrough } from "stream";
import { renderToPipeableStream } from "react-dom/server";
import { RemixServer } from "@remix-run/react";
import { createReadableStreamFromReadable } from "@remix-run/node";
import { isbot } from "isbot";
import { addDocumentResponseHeaders } from "./shopify.server";

export const streamTimeout = 5000;

export default async function handleRequest(
  request,
  responseStatusCode,
  responseHeaders,
  remixContext,
) {
  addDocumentResponseHeaders(request, responseHeaders);
  const userAgent = request.headers.get("user-agent");
  const callbackName = isbot(userAgent ?? "") ? "onAllReady" : "onShellReady";

  return new Promise((resolve, reject) => {
    const { pipe, abort } = renderToPipeableStream(
      <RemixServer context={remixContext} url={request.url} />,
      {
        [callbackName]: () => {
          const body = new PassThrough();
          const stream = createReadableStreamFromReadable(body);

          responseHeaders.set("Content-Type", "text/html");
          resolve(
            new Response(stream, {
              headers: responseHeaders,
              status: responseStatusCode,
            }),
          );
          pipe(body);
        },
        onShellError(error) {
          reject(error);
        },
        onError(error) {
          responseStatusCode = 500;
          console.error(error);
        },
      },
    );

    // Automatically timeout the React renderer after 6 seconds, which ensures
    // React has enough time to flush down the rejected boundary contents
    setTimeout(abort, streamTimeout + 1000);
  });
}


C:\Users\WEB PC\Desktop\web dev mustafa\geo-location\app\root.jsx
import { Links, LiveReload, Meta, Outlet, Scripts, ScrollRestoration } from "@remix-run/react";
import { AppProvider as ShopifyAppProvider } from "@shopify/shopify-app-remix/react";
import { AppProvider as PolarisAppProvider } from "@shopify/polaris";
import polarisStyles from "@shopify/polaris/build/esm/styles.css?url";
import translations from '@shopify/polaris/locales/en.json';
import { json } from "@remix-run/node"; 
import { useLoaderData } from "@remix-run/react";
import { authenticate } from "./shopify.server";


export const links = () => [{ rel: "stylesheet", href: polarisStyles }];

export const loader = async ({ request }) => {
  await authenticate.admin(request);
  return json({
    env: {
      SHOPIFY_API_KEY: process.env.SHOPIFY_API_KEY,
    }
  });
};

export default function App() {
  const { env } = useLoaderData(); 

  return (
    <html lang="en">
      <head>
        <Meta />
        <Links />
      
        <script
          src="https://unpkg.com/@shopify/app-bridge@3.7.9/dist/app-bridge.js"
          async
        />
      </head>
      <body>
        <ShopifyAppProvider
          isEmbeddedApp
          apiKey={env.SHOPIFY_API_KEY} 
        >
          <PolarisAppProvider i18n={translations}>
            <Outlet />
          </PolarisAppProvider>
        </ShopifyAppProvider>
        <ScrollRestoration />
        <Scripts />
        <LiveReload />
      </body>
    </html>
  );
}

C:\Users\WEB PC\Desktop\web dev mustafa\geo-location\app\db.server.js
import { PrismaClient } from "@prisma/client";


if (process.env.NODE_ENV !== "production") {
  if (!global.prismaGlobal) {
    global.prismaGlobal = new PrismaClient();
  }
}

const prisma = global.prismaGlobal ?? new PrismaClient();

export default prisma;

C:\Users\WEB PC\Desktop\web dev mustafa\geo-location\prisma\schema.prisma
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

// Note that some adapters may set a maximum length for the String type by default, please ensure your strings are long
// enough when changing adapters.
// See https://www.prisma.io/docs/orm/reference/prisma-schema-reference#string for more information
datasource db {
  provider = "sqlite"
  url      = "file:dev.sqlite"
}

model Session {
  id            String    @id
  shop          String
  state         String
  isOnline      Boolean   @default(false)
  scope         String?
  expires       DateTime?
  accessToken   String
  userId        BigInt?
  firstName     String?
  lastName      String?
  email         String?
  accountOwner  Boolean   @default(false)
  locale        String?
  collaborator  Boolean?  @default(false)
  emailVerified Boolean?  @default(false)
}

C:\Users\WEB PC\Desktop\web dev mustafa\geo-location\app\shopify.server.js
import "@shopify/shopify-app-remix/adapters/node";
import {
  ApiVersion,
  AppDistribution,
  shopifyApp,
} from "@shopify/shopify-app-remix/server";
import { PrismaSessionStorage } from "@shopify/shopify-app-session-storage-prisma";
import prisma from "./db.server";

const shopify = shopifyApp({
  apiKey: process.env.SHOPIFY_API_KEY,
  apiSecretKey: process.env.SHOPIFY_API_SECRET || "",
  apiVersion: ApiVersion.January25,
  scopes: process.env.SCOPES?.split(","),
  appUrl: process.env.SHOPIFY_APP_URL || "",
  authPathPrefix: "/auth",
  sessionStorage: new PrismaSessionStorage(prisma),
  distribution: AppDistribution.AppStore,
  future: {
    unstable_newEmbeddedAuthStrategy: true,
    removeRest: true,
  },
  ...(process.env.SHOP_CUSTOM_DOMAIN
    ? { customShopDomains: [process.env.SHOP_CUSTOM_DOMAIN] }
    : {}),
});

export default shopify;
export const apiVersion = ApiVersion.January25;
export const addDocumentResponseHeaders = shopify.addDocumentResponseHeaders;
export const authenticate = shopify.authenticate;
export const unauthenticated = shopify.unauthenticated;
export const login = shopify.login;
export const registerWebhooks = shopify.registerWebhooks;
export const sessionStorage = shopify.sessionStorage;

C:\Users\WEB PC\Desktop\web dev mustafa\geo-location\app\routes\_index\route.jsx
import { redirect } from "@remix-run/node";
import { Form, useLoaderData } from "@remix-run/react";
import { login } from "../../shopify.server";
import styles from "./styles.module.css";

export const loader = async ({ request }) => {
  const url = new URL(request.url);

  if (url.searchParams.get("shop")) {
    throw redirect(`/app?${url.searchParams.toString()}`);
  }

  return { showForm: Boolean(login) };
};

export default function App() {
  const { showForm } = useLoaderData();

  return (
    <div className={styles.index}>
      <div className={styles.content}>
        <h1 className={styles.heading}>A short heading about [your app]</h1>
        <p className={styles.text}>
          A tagline about [your app] that describes your value proposition.
        </p>
        {showForm && (
          <Form className={styles.form} method="post" action="/auth/login">
            <label className={styles.label}>
              <span>Shop domain</span>
              <input className={styles.input} type="text" name="shop" />
              <span>e.g: my-shop-domain.myshopify.com</span>
            </label>
            <button className={styles.button} type="submit">
              Log in
            </button>
          </Form>
        )}
        <ul className={styles.list}>
          <li>
            <strong>Product feature</strong>. Some detail about your feature and
            its benefit to your customer.
          </li>
          <li>
            <strong>Product feature</strong>. Some detail about your feature and
            its benefit to your customer.
          </li>
          <li>
            <strong>Product feature</strong>. Some detail about your feature and
            its benefit to your customer.
          </li>
        </ul>
      </div>
    </div>
  );
}


C:\Users\WEB PC\Desktop\web dev mustafa\geo-location\app\routes\create-rule.jsx
import { useAppBridge } from "@shopify/app-bridge-react";
import { json } from "@remix-run/node";
import { Form, useLoaderData, useNavigation, useFetcher } from "@remix-run/react";
import {
  Button,
  Page,
  Layout,
  Card,
  FormLayout,
  TextField,
  Text,
  Select,
  Checkbox,
  Box,
  ChoiceList
} from "@shopify/polaris";
import { useState, useCallback, useEffect } from "react";
import { authenticate } from "../shopify.server";
import prisma from "../db.server";
import { CountrySelector } from "../components/CountrySearch";
import { checkAndSendNotifications } from "../utils/notification";


export async function loader({ request }) {
  const { session } = await authenticate.admin(request);
  const { shop, accessToken } = session;

  let allProducts = [];
  let allCollections = [];
  let allVendors = [];
  let allTags = [];
  let cursor = null;
  let hasNextPage = true;

  while (hasNextPage) {
    const query = `
      query getProducts($cursor: String) {
        products(first: 250, after: $cursor) {
          edges {
            node {
              id
              title
              tags
              vendor
              productType
              collections(first: 100) {
                edges {
                  node {
                    id
                    title
                  }
                }
              }
            }
          }
          pageInfo {
            hasNextPage
            endCursor
          }
        }
      }
    `;
    const response = await fetch(`https://${shop}/admin/api/2024-04/graphql.json`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "X-Shopify-Access-Token": accessToken,
      },
      body: JSON.stringify({ query, variables: { cursor } }),
    });

    if (!response.ok) {
      return json({ error: `HTTP error! status: ${response.status}` });
    }

    const result = await response.json();
    if (result.errors) {
      console.error("GraphQL errors:", result.errors);
      return json({ error: "GraphQL query failed" }, { status: 500 });
    }

    const responseData = result.data?.products;
    if (!responseData) {
      return json({ error: "No products data returned from Shopify" });
    }

    allProducts = [
      ...allProducts,
      ...responseData.edges.map(edge => ({
        ...edge.node,
        id: edge.node.id.split("/").pop(),
        collections: edge.node.collections.edges.map(e => ({
          ...e.node,
          id: e.node.id.split("/").pop(),
        })),
      })),
    ];
    hasNextPage = responseData.pageInfo.hasNextPage;
    cursor = responseData.pageInfo.endCursor;

    responseData.edges.forEach(edge => {
      const { vendor, tags } = edge.node;
      if (vendor && !allVendors.some(v => v.name === vendor)) {
        allVendors.push({ name: vendor });
      }
      tags.forEach(tag => {
        if (!allTags.some(t => t.name === tag)) {
          allTags.push({ name: tag });
        }
      });
    });
  }

  hasNextPage = true;
  cursor = null;
  while (hasNextPage) {
    const query = `
      query getCollections($cursor: String) {
        collections(first: 250, after: $cursor) {
          edges {
            node {
              id
              title
            }
          }
          pageInfo {
            hasNextPage
            endCursor
          }
        }
      }
    `;
    const response = await fetch(`https://${shop}/admin/api/2024-04/graphql.json`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "X-Shopify-Access-Token": accessToken,
      },
      body: JSON.stringify({ query, variables: { cursor } }),
    });

    if (!response.ok) {
      return json({ error: `HTTP error! status: ${response.status}` });
    }

    const result = await response.json();
    if (result.errors) {
      console.error("GraphQL errors:", result.errors);
      return json({ error: "GraphQL query failed" }, { status: 500 });
    }

    const responseData = result.data?.collections;
    if (!responseData) {
      return json({ error: "No collections data returned from Shopify" });
    }

    allCollections = [
      ...allCollections,
      ...responseData.edges.map(edge => ({
        ...edge.node,
        id: edge.node.id.split("/").pop(),
      })),
    ];
    hasNextPage = responseData.pageInfo.hasNextPage;
    cursor = responseData.pageInfo.endCursor;
  }

  return json({ allProducts, allCollections, allVendors, allTags });
}

export async function action({ request }) {
  const formData = await request.formData();
  const actionType = formData.get("actionType");

  if (actionType === "create") {
    const productIds = formData.getAll("productId");
    const collectionIds = formData.getAll("collectionId");
    const vendorNames = formData.getAll("vendorName");
    const tagNames = formData.getAll("tagName");
    const productExcluded = formData.getAll("productExcluded").map((val) => val === "true");
    const productNotificationsEnabled = formData.getAll("productNotificationsEnabled").map((val) => val === "true");
    const productTitles = formData.getAll("productTitle");
    const collectionExcluded = formData.getAll("collectionExcluded").map((val) => val === "true");
    const collectionNotificationsEnabled = formData.getAll("collectionNotificationsEnabled").map((val) => val === "true");
    const collectionTitles = formData.getAll("collectionTitle");
    const vendorExcluded = formData.getAll("vendorExcluded").map((val) => val === "true");
    const vendorNotificationsEnabled = formData.getAll("vendorNotificationsEnabled").map((val) => val === "true");
    const tagExcluded = formData.getAll("tagExcluded").map((val) => val === "true");
    const tagNotificationsEnabled = formData.getAll("tagNotificationsEnabled").map((val) => val === "true");
    const country = formData.get("country");
    const deliveryTime = formData.get("deliveryTime") || null;
    const message = formData.get("message") || null;
    const eventName = formData.get("eventName") || null;
    const startDate = formData.get("startDate");
    const endDate = formData.get("endDate");
    const shippingMethod = formData.get("shippingMethod");
    const pickupAvailable = formData.get("pickupAvailable") === "true";
    const localDelivery = formData.get("localDelivery")?.replace(/^"|"$/g, "") || null;
    const zipCodes = formData.get("zipCodes") || "";
    const zipCodeType = formData.get("zipCodeType") || "inclusive";


    // ✅ Log all parsed form data before DB operations
    console.log("🔍 Parsed form data:");
    console.table([
      { key: "country", value: country },
      { key: "deliveryTime", value: deliveryTime },
      { key: "message", value: message },
      { key: "eventName", value: eventName },
      { key: "startDate", value: startDate },
      { key: "endDate", value: endDate },
      { key: "shippingMethod", value: shippingMethod },
      { key: "pickupAvailable", value: pickupAvailable },
      { key: "localDelivery", value: localDelivery },
      { key: "zipCodes", value: zipCodes },
      { key: "zipCodeType", value: zipCodeType },
    ]);

    console.log("📦 productIds:", productIds);
    console.log("📦 collectionIds:", collectionIds);
    console.log("📦 vendorNames:", vendorNames);
    console.log("📦 tagNames:", tagNames);

    console.log("🚫 productExcluded:", productExcluded);
    console.log("🔔 productNotificationsEnabled:", productNotificationsEnabled);
    console.log("🚫 collectionExcluded:", collectionExcluded);
    console.log("🔔 collectionNotificationsEnabled:", collectionNotificationsEnabled);
    console.log("🚫 vendorExcluded:", vendorExcluded);

    if (!country) {
      return json({ error: "Country selection is required" }, { status: 400 });
    }
    if (startDate && endDate && new Date(startDate) > new Date(endDate)) {
      return json({ error: "Start date cannot be after end date" }, { status: 400 });
    }
    if (!productIds.length && !collectionIds.length && !vendorNames.length && !tagNames.length) {
      return json({ error: "At least one resource is required" }, { status: 400 });
    }
    if (endDate) {
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      const end = new Date(endDate);
      if (end < today) {
        return json({ error: "End date cannot be in the past" }, { status: 400 });
      }
    }
    if (deliveryTime && deliveryTime.length < 3) {
      return json({ error: "Delivery time must be descriptive (e.g., 1-2 days)" }, { status: 400 });
    }
    if (zipCodes && zipCodes.trim() !== "") {
      const zipCodeArray = zipCodes.split(",").map((z) => z.trim());
      const invalidZipCodes = zipCodeArray.filter(
        (zip) => !/^\d+(-\d+)?$/.test(zip) && !/^\d+\*$/.test(zip)
      );
      if (invalidZipCodes.length > 0) {
        return json({ error: `Invalid zip code format: ${invalidZipCodes.join(", ")}` }, { status: 400 });
      }
    }

    const { session } = await authenticate.admin(request);
    const { shop } = session;

    try {
      const result = await prisma.$transaction(async (tx) => {
        let existingRule = await tx.rule.findFirst({
          where: {
            shop,
            country,
            OR: [
              { productRules: { some: { productId: { in: productIds } } } },
              { collectionRules: { some: { collectionId: { in: collectionIds } } } },
              { VendorRules: { some: { vendorName: { in: vendorNames } } } },
              { TagRules: { some: { tagName: { in: tagNames } } } },
            ],
          },
          include: { productRules: true, collectionRules: true, VendorRules: true, TagRules: true },
        });

        if (!existingRule) {
          const conflictingRules = await tx.rule.findMany({
            where: {
              shop,
              country,
              OR: [
                { zipCodes: zipCodes.trim() || null, zipCodeType },
                ...(zipCodes.trim() === "" ? [] : [{ zipCodes: null }]),
              ],
            },
            include: {
              productRules: { where: { productId: { in: productIds } } },
              collectionRules: { where: { collectionId: { in: collectionIds } } },
              VendorRules: { where: { vendorName: { in: vendorNames } } },
              TagRules: { where: { tagName: { in: tagNames } } },
            },
          });

          const relevantConflicts = conflictingRules.filter(
            (rule) =>
              rule.productRules.length > 0 ||
              rule.collectionRules.length > 0 ||
              rule.VendorRules.length > 0 ||
              rule.TagRules.length > 0
          );

          if (relevantConflicts.length > 0) {
            return json({ error: "Conflicting rules found. Please delete existing rules first." });
          }
        }

        let ruleId;
        let previouslyExcludedProducts = [];
        if (existingRule) {
          ruleId = existingRule.id;
          previouslyExcludedProducts = existingRule.productRules
            .filter((pr) => pr.excluded)
            .map((pr) => pr.productId);
          await tx.rule.update({
            where: { id: ruleId },
            data: {
              deliveryTime,
              shippingMethod,
              message,
              eventName,
              startDate: startDate ? new Date(startDate) : null,
              endDate: endDate ? new Date(endDate) : null,
              pickupAvailable,
              localDelivery,
              zipCodes: zipCodes.trim() || null,
              zipCodeType,
            },
          });
        } else {
          const newRule = await tx.rule.create({
            data: {
              shop,
              country,
              deliveryTime,
              shippingMethod,
              message,
              eventName,
              startDate: startDate ? new Date(startDate) : null,
              endDate: endDate ? new Date(endDate) : null,
              pickupAvailable,
              localDelivery,
              zipCodes: zipCodes.trim() || null,
              zipCodeType,
            },
          });
          ruleId = newRule.id;
        }

        let createdCount = 0;
        const updatedProductIds = [];
        for (let i = 0; i < productIds.length; i++) {
          const productId = productIds[i];
          const excluded = productExcluded[i] || false;
          const notificationsEnabled = productNotificationsEnabled[i] || false;
          const productTitle = productTitles[i];

          await tx.product.upsert({
            where: { id: productId },
            update: { shop, title: productTitle },
            create: { id: productId, shop, title: productTitle },
          });

          await tx.productRule.upsert({
            where: { ruleId_productId: { ruleId, productId } },
            update: { excluded, notificationsEnabled },
            create: { ruleId, productId, excluded, notificationsEnabled },
          });
          updatedProductIds.push({ productId, excluded, notificationsEnabled });
          createdCount++;
        }

        for (let i = 0; i < collectionIds.length; i++) {
          const collectionId = collectionIds[i];
          const excluded = collectionExcluded[i] || false;
          const notificationsEnabled = collectionNotificationsEnabled[i] || false;
          const collectionTitle = collectionTitles[i];

          await tx.collection.upsert({
            where: { id: collectionId },
            update: { shop, title: collectionTitle },
            create: { id: collectionId, shop, title: collectionTitle },
          });

          await tx.collectionRule.upsert({
            where: { ruleId_collectionId: { ruleId, collectionId } },
            update: { excluded, notificationsEnabled },
            create: { ruleId, collectionId, excluded, notificationsEnabled },
          });
          createdCount++;
        }

        for (let i = 0; i < vendorNames.length; i++) {
          const vendorName = vendorNames[i];
          const excluded = vendorExcluded[i] || false;
          const notificationsEnabled = vendorNotificationsEnabled[i] || false;

          await tx.vendor.upsert({
            where: { name: vendorName },
            update: { shop },
            create: { name: vendorName, shop },
          });

          await tx.vendorRule.upsert({
            where: { ruleId_vendorName: { ruleId, vendorName } },
            update: { excluded, notificationsEnabled },
            create: { ruleId, vendorName, excluded, notificationsEnabled },
          });
          createdCount++;
        }

        for (let i = 0; i < tagNames.length; i++) {
          const tagName = tagNames[i];
          const excluded = tagExcluded[i] || false;
          const notificationsEnabled = tagNotificationsEnabled[i] || false;

          await tx.tag.upsert({
            where: { name: tagName },
            update: { shop },
            create: { name: tagName, shop },
          });

          await tx.tagRule.upsert({
            where: { ruleId_tagName: { ruleId, tagName } },
            update: { excluded, notificationsEnabled },
            create: { ruleId, tagName, excluded, notificationsEnabled },
          });
          createdCount++;
        }

        console.log("✅ transaction finished – ruleId:", ruleId, "createdCount:", createdCount);
        
        return {
          success: true,
          createdCount,
          ruleId,
          previouslyExcludedProducts,
          updatedProductIds,
        };
      });

      if (result.previouslyExcludedProducts.length > 0) {
        const newlyIncluded = result.updatedProductIds
          .filter(
            (upd) =>
              !upd.excluded &&
              result.previouslyExcludedProducts.includes(upd.productId) &&
              upd.notificationsEnabled
          )
          .map((upd) => upd.productId);
        if (newlyIncluded.length > 0) {
          console.log("Triggering notifications for newly included products:", newlyIncluded);
          await checkAndSendNotifications({ productIds: newlyIncluded, country });
        }
      }

      return json(result);
    } catch (error) {
      console.error("Error creating rules:", error);
      if (error.message.includes("Conflicting rules found")) {
        return json({ error: error.message }, { status: 400 });
      }
      return json({ error: `Failed to save rules: ${error.message}` }, { status: 500 });
    }
  }

  if (actionType === "search") {
    const searchType = formData.get("searchType");
    const searchQuery = formData.get("searchQuery")?.trim();
    const { session } = await authenticate.admin(request);
    const { shop, accessToken } = session;

    if (!searchQuery) {
      return json({ items: [], error: `Please enter a ${searchType} name to search` }, { status: 400 });
    }

    let query = "";
    let queryString = `*${searchQuery}*`;

    if (searchType === "vendor") {
      query = `
        query getProductsByVendor($query: String) {
          products(first: 250, query: $query) {
            edges {
              node {
                id
                title
                vendor
              }
            }
          }
        }
      `;
      queryString = `vendor:${queryString}`;
    } else if (searchType === "tag") {
      query = `
        query getProductsByTag($query: String) {
          products(first: 250, query: $query) {
            edges {
              node {
                id
                title
                tags
              }
            }
          }
        }
      `;
      queryString = `tag:${queryString}`;
    } else {
      return json({ items: [], error: "Invalid search type" }, { status: 400 });
    }

    const response = await fetch(`https://${shop}/admin/api/2024-04/graphql.json`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "X-Shopify-Access-Token": accessToken,
      },
      body: JSON.stringify({ query, variables: { query: queryString } }),
    });

    if (!response.ok) {
      return json({ items: [], error: `Failed to fetch: ${response.statusText}` }, { status: response.status });
    }

    const result = await response.json();
    if (result.errors) {
      return json({ items: [], error: `GraphQL error: ${result.errors[0]?.message || "Unknown error"}` }, { status: 500 });
    }

    let items = [];
    if (searchType === "vendor") {
      const products = result.data?.products?.edges || [];
      items = [...new Set(products.map(edge => edge.node.vendor))]
        .map(name => ({ name }))
        .filter(v => v.name.toLowerCase().includes(searchQuery.toLowerCase()));
    } else if (searchType === "tag") {
      const products = result.data?.products?.edges || [];
      items = [...new Set(products.flatMap(edge => edge.node.tags))]
        .map(name => ({ name }))
        .filter(t => t.name.toLowerCase().includes(searchQuery.toLowerCase()));
    }

    if (items.length === 0) {
      return json({ items: [], error: `No ${searchType}s found for "${searchQuery}"` });
    }

    return json({ items, type: searchType + "s" });
  }

  if (actionType === "notify") {
    const email = formData.get("email");
    const productId = formData.get("productId");
    const collectionId = formData.get("collectionId");
    const vendorName = formData.get("vendorName");
    const tagName = formData.get("tagName");
    const country = formData.get("country");

    // const rule = await prisma.rule.findFirst({
    //   where: {
    //     OR: [
    //       productId ? { productRules: { some: { productId, notificationsEnabled: true } } } : {},
    //       collectionId ? { collectionRules: { some: { collectionId, notificationsEnabled: true } } } : {},
    //       vendorName ? { VendorRules: { some: { vendorName, notificationsEnabled: true } } } : {},
    //       tagName ? { TagRules: { some: { tagName, notificationsEnabled: true } } } : {},
    //     ],
    //     country: { equals: country, mode: "insensitive" },
    //   },
    // });

    if (!rule) {
      return json({ error: "Notifications are disabled for this resource or region" }, { status: 403 });
    }

    if (!email || !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
      return json({ error: "Valid email is required" }, { status: 400 });
    }

    try {
      await prisma.notificationSignup.create({
        data: { email, productId, collectionId, vendorName, tagName, country },
      });
      return json({ success: true, message: "You'll be notified when available!" });
    } catch (error) {
      console.error("Error saving notification:", error);
      return json({ error: `Failed to save notification: ${error.message}` }, { status: 500 });
    }
  }

  return json({ success: true });
}


export default function CreateRule() {
  const app = useAppBridge();
  const fetcher = useFetcher();
  const navigation = useNavigation();
  const [resourceType, setResourceType] = useState("product");
  const [searchQuery, setSearchQuery] = useState("");
  const [country, setCountry] = useState("");
  const [eventName, setEventName] = useState("");
  const [startDate, setStartDate] = useState("");
  const [endDate, setEndDate] = useState("");
  const [deliveryTime, setDeliveryTime] = useState("");
  const [shipping, setShipping] = useState("express");
  const [message, setMessage] = useState("");
  const [pickupAvailable, setPickupAvailable] = useState(false);
  const [localDelivery, setLocalDelivery] = useState("");
  const [zipCodes, setZipCodes] = useState("");
  const [zipCodeType, setZipCodeType] = useState("inclusive");
  const [offerState, setOfferState] = useState({
    selectedProducts: [],
    selectedCollections: [],
    selectedVendors: [],
    selectedTags: [],
  });
  const [excludedItems, setExcludedItems] = useState({
    products: [], collections: [], vendors: [], tags: [],
  });
  const [notifications, setNotifications] = useState({
    products: {}, collections: {}, vendors: {}, tags: {},
  });
  const [errors, setErrors] = useState({
    country: "", startDate: "", endDate: "", deliveryTime: "", resources: "", zipCodes: "",
  });
  const [isSubmitting, setIsSubmitting] = useState(false);

  const validateForm = () => {
    const newErrors = {
      country: "", startDate: "", endDate: "", deliveryTime: "", resources: "", zipCodes: "",
    };
    let isValid = true;

    if (!country) {
      newErrors.country = "Country selection is required";
      isValid = false;
    }
    if (!startDate) {
      newErrors.startDate = "Start date is required";
      isValid = false;
    }
    if (!endDate) {
      newErrors.endDate = "End date is required";
      isValid = false;
    } else if (startDate && new Date(startDate) > new Date(endDate)) {
      newErrors.endDate = "End date must be after start date";
      isValid = false;
    } else if (new Date(endDate) < new Date().setHours(0, 0, 0, 0)) {
      newErrors.endDate = "End date cannot be in the past";
      isValid = false;
    }
    if (!deliveryTime) {
      newErrors.deliveryTime = "Delivery time is required";
      isValid = false;
    } else if (deliveryTime.length < 3) {
      newErrors.deliveryTime = "Enter a descriptive time (e.g., 1-2 days)";
      isValid = false;
    }
    if (
      offerState.selectedProducts.length === 0 &&
      offerState.selectedCollections.length === 0 &&
      offerState.selectedVendors.length === 0 &&
      offerState.selectedTags.length === 0
    ) {
      newErrors.resources = "Please select at least one resource";
      isValid = false;
    }
    if (zipCodes && zipCodes.trim() !== "") {
      const zipCodeArray = zipCodes.split(',').map(z => z.trim());
      const invalidZipCodes = zipCodeArray.filter(zip => !/^\d+(-\d+)?$/.test(zip) && !/^\d+\*$/.test(zip));
      if (invalidZipCodes.length > 0) {
        newErrors.zipCodes = `Invalid zip code format: ${invalidZipCodes.join(', ')}`;
        isValid = false;
      }
    }
    setErrors(newErrors);
    return isValid;
  };

  // const handleSubmit = async (e) => {
  //   e.preventDefault();
  //   setIsSubmitting(true);
  //   if (!validateForm()) {
  //     setIsSubmitting(false);
  //     return;
  //   }
  //   if (navigation.state === "submitting") return;

  //   const formData = new FormData();
  //   formData.append("actionType", "create");
  //   formData.append("country", country);
  //   formData.append("deliveryTime", deliveryTime);
  //   formData.append("shippingMethod", shipping);
  //   formData.append("message", message);
  //   formData.append("eventName", eventName);
  //   formData.append("startDate", startDate);
  //   formData.append("endDate", endDate);
  //   formData.append("pickupAvailable", pickupAvailable.toString());
  //   formData.append("localDelivery", localDelivery);
  //   formData.append("zipCodes", zipCodes);
  //   formData.append("zipCodeType", zipCodeType);

  //   offerState.selectedProducts.forEach((product) => {
  //     formData.append("productId", product.id);
  //     formData.append("productExcluded", excludedItems.products.includes(product.id) ? "true" : "false");
  //     formData.append("productNotificationsEnabled", notifications.products[product.id] ? "true" : "false");
  //     formData.append("productTitle", product.title);
  //   });
  //   offerState.selectedCollections.forEach((collection) => {
  //     formData.append("collectionId", collection.id);
  //     formData.append("collectionExcluded", excludedItems.collections.includes(collection.id) ? "true" : "false");
  //     formData.append("collectionNotificationsEnabled", notifications.collections[collection.id] ? "true" : "false");
  //     formData.append("collectionTitle", collection.title);
  //   });
  //   offerState.selectedVendors.forEach(vendor => {
  //     formData.append("vendorName", vendor.name);
  //     formData.append("vendorExcluded", excludedItems.vendors.includes(vendor.name) ? "true" : "false");
  //     formData.append("vendorNotificationsEnabled", notifications.vendors[vendor.name] ? "true" : "false");
  //   });

  //   offerState.selectedTags.forEach(tag => {
  //     formData.append("tagName", tag.name);
  //     formData.append("tagExcluded", excludedItems.tags.includes(tag.name) ? "true" : "false");
  //     formData.append("tagNotificationsEnabled", notifications.tags[tag.name] ? "true" : "false");
  //   });


  //   fetcher.submit(formData, { method: "POST", encType: "multipart/form-data" });
  //  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    setIsSubmitting(true);
    if (!validateForm()) {
      setIsSubmitting(false);
      return;
    }
    if (navigation.state === "submitting") return;

    const formData = new FormData();
    formData.append("actionType", "create");
    formData.append("country", country);
    formData.append("deliveryTime", deliveryTime);
    formData.append("shippingMethod", shipping);
    formData.append("message", message);
    formData.append("eventName", eventName);
    formData.append("startDate", startDate);
    formData.append("endDate", endDate);
    formData.append("pickupAvailable", pickupAvailable.toString());
    formData.append("localDelivery", localDelivery);
    formData.append("zipCodes", zipCodes);
    formData.append("zipCodeType", zipCodeType);

    offerState.selectedProducts.forEach((product) => {
      formData.append("productId", product.id);
      formData.append("productExcluded", excludedItems.products.includes(product.id) ? "true" : "false");
      formData.append("productNotificationsEnabled", notifications.products[product.id] ? "true" : "false");
      formData.append("productTitle", product.title);
    });

    offerState.selectedCollections.forEach((collection) => {
      formData.append("collectionId", collection.id);
      formData.append("collectionExcluded", excludedItems.collections.includes(collection.id) ? "true" : "false");
      formData.append("collectionNotificationsEnabled", notifications.collections[collection.id] ? "true" : "false");
      formData.append("collectionTitle", collection.title);
    });

    offerState.selectedVendors.forEach((vendor) => {
      formData.append("vendorName", vendor.name);
      formData.append("vendorExcluded", excludedItems.vendors.includes(vendor.name) ? "true" : "false");
      formData.append("vendorNotificationsEnabled", notifications.vendors[vendor.name] ? "true" : "false");
    });

    offerState.selectedTags.forEach((tag) => {
      formData.append("tagName", tag.name);
      formData.append("tagExcluded", excludedItems.tags.includes(tag.name) ? "true" : "false");
      formData.append("tagNotificationsEnabled", notifications.tags[tag.name] ? "true" : "false");
    });

    // ✅ Debugging logs
    console.log("📦 FormData being submitted:");
    for (let [key, value] of formData.entries()) {
      console.log(`${key}: ${value}`);
    }

    console.log("🧾 Final offerState:", offerState);
    console.log("🧾 Excluded items:", excludedItems);
    console.log("🧾 Notifications:", notifications);

    fetcher.submit(formData, { method: "POST", encType: "multipart/form-data" });
  };

  useEffect(() => {
    if (fetcher.data?.success) {
      setOfferState({ selectedProducts: [], selectedCollections: [], selectedVendors: [], selectedTags: [] });
      setExcludedItems({ products: [], collections: [], vendors: [], tags: [] });
      setNotifications({ products: {}, collections: {}, vendors: {}, tags: {} });
      setCountry("");
      setDeliveryTime("");
      setMessage("");
      setStartDate("");
      setEndDate("");
      setEventName("");
      setShipping("express");
      setZipCodes("");
      setZipCodeType("inclusive");
      setResourceType("product");
      setSearchQuery("");
    }
  }, [fetcher.data]);


  const shippingMethods = [
    { label: "Express", value: "express" },
    { label: "Standard", value: "standard" },
  ];

  const resourceTypes = [
    { label: "Products", value: "product" },
    { label: "Collections", value: "collection" },
    { label: "Vendors", value: "vendor" },
    { label: "Tags", value: "tag" },
  ];

  async function resourcePicker() {
    try {
      if (resourceType === "vendor" || resourceType === "tag") {
        if (!searchQuery) {
          setErrors((prev) => ({ ...prev, resources: "Please enter a search query for vendors or tags" }));
          return;
        }
        const formData = new FormData();
        formData.append("actionType", "search");
        formData.append("searchType", resourceType);
        formData.append("searchQuery", searchQuery);
        fetcher.submit(formData, { method: "POST" });
      } else {
        const pickerOptions = {
          type: resourceType,
          action: "select",
          multiple: true,
          showVariants: resourceType === "product" ? false : undefined,
        };
        const selectedItems = await window.shopify.resourcePicker(pickerOptions);
        if (selectedItems) {
          let newItems;
          if (resourceType === "product") {
            newItems = selectedItems.map((item) => ({
              id: item.id.split("/").pop(),
              title: item.title,
            }));
            setOfferState((prev) => ({
              ...prev,
              selectedProducts: [...prev.selectedProducts, ...newItems].filter(
                (item, index, self) => index === self.findIndex((i) => i.id === item.id)
              ),
            }));
            setNotifications((prev) => {
              const updated = { ...prev.products };
              newItems.forEach((item) => {
                if (!(item.id in updated)) updated[item.id] = true;
              });
              return { ...prev, products: updated };
            });
          } else if (resourceType === "collection") {
            newItems = selectedItems.map((item) => ({
              id: item.id.split("/").pop(),
              title: item.title,
            }));
            setOfferState((prev) => ({
              ...prev,
              selectedCollections: [...prev.selectedCollections, ...newItems].filter(
                (item, index, self) => index === self.findIndex((i) => i.id === item.id)
              ),
            }));
            setNotifications((prev) => {
              const updated = { ...prev.collections };
              newItems.forEach((item) => {
                if (!(item.id in updated)) updated[item.id] = true;
              });
              return { ...prev, collections: updated };
            });
          }
        }
      }
    } catch (error) {
      console.error("Error in resource picker:", error);
      setErrors((prev) => ({ ...prev, resources: "Error selecting resources" }));
    }
  }

  const toggleExcludeItem = useCallback((type, id) => {
    setExcludedItems((prev) => ({
      ...prev,
      [type]: prev[type].includes(id)
        ? prev[type].filter((itemId) => itemId !== id)
        : [...prev[type], id],
    }));
  }, []);

  const toggleNotification = useCallback((type, id) => {
    setNotifications((prev) => ({
      ...prev,
      [type]: {
        ...prev[type],
        [id]: !prev[type][id],
      },
    }));
  }, []);

  const removeItem = useCallback((type, id) => {
    setOfferState((prev) => ({
      ...prev,
      [`selected${type.charAt(0).toUpperCase() + type.slice(1)}s`]: prev[
        `selected${type.charAt(0).toUpperCase() + type.slice(1)}s`
      ].filter((item) => item.id !== id && item.name !== id),
    }));
    setExcludedItems((prev) => ({
      ...prev,
      [type]: prev[type].filter((itemId) => itemId !== id),
    }));
    setNotifications((prev) => {
      const updated = { ...prev[type] };
      delete updated[id];
      return { ...prev, [type]: updated };
    });
  }, []);

  return (
    <Page title="Create Shipping Rule">
      <Layout>
        <Layout.Section>
          <Card title="Shipping Rule Details" sectioned>
            <FormLayout>
              <Card sectioned>
                <Text variant="headingSm" as="h3" fontWeight="bold">
                  Resource Selection
                </Text>
                <Box style={{ display: "flex", flexDirection: "column", gap: "16px" }}>
                  <Select
                    label="Select Resource Type"
                    options={resourceTypes}
                    value={resourceType}
                    onChange={(value) => {
                      setResourceType(value);
                      setSearchQuery("");
                      setErrors((prev) => ({ ...prev, resources: "" }));
                    }}
                  />
                  {(resourceType === "vendor" || resourceType === "tag") && (
                    <TextField
                      label={`Search ${resourceType.charAt(0).toUpperCase() + resourceType.slice(1)}`}
                      value={searchQuery}
                      onChange={setSearchQuery}
                      placeholder={`Enter ${resourceType} name (e.g., Nike, Sale)`}
                      autoComplete="off"
                    />
                  )}
                  <Button
                    onClick={resourcePicker}
                    primary
                    disabled={fetcher.state === "submitting" || (resourceType === "vendor" || resourceType === "tag") && !searchQuery}
                    loading={fetcher.state === "submitting"}
                  >
                    {resourceType === "vendor" || resourceType === "tag"
                      ? `Search ${resourceTypes.find((rt) => rt.value === resourceType)?.label}`
                      : `Select ${resourceTypes.find((rt) => rt.value === resourceType)?.label}`}
                  </Button>
                  {errors.resources && <Text tone="critical">{errors.resources}</Text>}
                  {fetcher.data?.items?.length > 0 && (fetcher.data.type === "vendors" || fetcher.data.type === "tags") && (
                    <Card sectioned>
                      <Text variant="headingXs" as="h4" fontWeight="semibold">
                        {fetcher.data.type === "vendors" ? "Vendors" : "Tags"} Found
                      </Text>
                      <Box style={{ display: "flex", flexDirection: "column", gap: "8px" }}>
                        {fetcher.data.items.map((item) => (
                          <Box
                            key={item.name}
                            style={{
                              display: "flex",
                              justifyContent: "space-between",
                              alignItems: "center",
                              padding: "12px",
                              backgroundColor: "var(--p-surface)",
                              borderRadius: "4px",
                            }}
                          >
                            <Text variant="bodyMd" fontWeight="medium">{item.name}</Text>
                            <Button
                              onClick={() => {
                                const typeKey = fetcher.data.type;
                                setOfferState((prev) => ({
                                  ...prev,
                                  [`selected${typeKey.charAt(0).toUpperCase() + typeKey.slice(1)}`]: [
                                    ...prev[`selected${typeKey.charAt(0).toUpperCase() + typeKey.slice(1)}`],
                                    { name: item.name, id: item.name },
                                  ].filter(
                                    (i, index, self) => index === self.findIndex((s) => s.name === i.name)
                                  ),
                                }));
                                setNotifications((prev) => ({
                                  ...prev,
                                  [typeKey]: {
                                    ...prev[typeKey],
                                    [item.name]: true,
                                  },
                                }));
                              }}
                              disabled={offerState[
                                `selected${fetcher.data.type.charAt(0).toUpperCase() + fetcher.data.type.slice(1)}`
                              ].some((i) => i.name === item.name)}
                            >
                              Add
                            </Button>
                          </Box>
                        ))}
                      </Box>
                    </Card>
                  )}
                  {fetcher.data?.error && <Text tone="critical">{fetcher.data.error}</Text>}
                </Box>
              </Card>

              {/* Selected Products */}
              {offerState.selectedProducts.length > 0 && (
                <Card sectioned>
                  <Text variant="headingXs" as="h4" fontWeight="semibold">Selected Products</Text>
                  <Box style={{ display: "flex", flexDirection: "column", gap: "8px" }}>
                    {offerState.selectedProducts.map((product) => (
                      <Box
                        key={product.id}
                        style={{
                          display: "flex",
                          justifyContent: "space-between",
                          alignItems: "center",
                          padding: "12px",
                          backgroundColor: "var(--p-surface)",
                          borderRadius: "4px",
                        }}
                      >
                        <Text variant="bodyMd" fontWeight="medium">{product.title}</Text>
                        <Box style={{ display: "flex", gap: "8px", alignItems: "center" }}>
                          <Checkbox
                            label="Exclude"
                            checked={excludedItems.products.includes(product.id)}
                            onChange={() => toggleExcludeItem("products", product.id)}
                          />
                          <Checkbox
                            label="Notifications"
                            checked={notifications.products[product.id] || false}
                            onChange={() => toggleNotification("products", product.id)}
                          />
                          <Button
                            plain
                            onClick={() => removeItem("products", product.id)}
                            tone="critical"
                          >
                            Remove
                          </Button>
                        </Box>
                      </Box>
                    ))}
                  </Box>
                </Card>
              )}

              {/* Selected Collections */}
              {offerState.selectedCollections.length > 0 && (
                <Card sectioned>
                  <Text variant="headingXs" as="h4" fontWeight="semibold">Selected Collections</Text>
                  <Box style={{ display: "flex", flexDirection: "column", gap: "8px" }}>
                    {offerState.selectedCollections.map((collection) => (
                      <Box
                        key={collection.id}
                        style={{
                          display: "flex",
                          justifyContent: "space-between",
                          alignItems: "center",
                          padding: "12px",
                          backgroundColor: "var(--p-surface)",
                          borderRadius: "4px",
                        }}
                      >
                        <Text variant="bodyMd" fontWeight="medium">{collection.title}</Text>
                        <Box style={{ display: "flex", gap: "8px", alignItems: "center" }}>
                          <Checkbox
                            label="Exclude"
                            checked={excludedItems.collections.includes(collection.id)}
                            onChange={() => toggleExcludeItem("collections", collection.id)}
                          />
                          <Checkbox
                            label="Notifications"
                            checked={notifications.collections[collection.id] || false}
                            onChange={() => toggleNotification("collections", collection.id)}
                          />
                          <Button
                            plain
                            onClick={() => removeItem("collections", collection.id)}
                            tone="critical"
                          >
                            Remove
                          </Button>
                        </Box>
                      </Box>
                    ))}
                  </Box>
                </Card>
              )}

              {/* Selected Vendors */}
              {offerState.selectedVendors.length > 0 && (
                <Card sectioned>
                  <Text variant="headingXs" as="h4" fontWeight="semibold">Selected Vendors</Text>
                  <Box style={{ display: "flex", flexDirection: "column", gap: "8px" }}>
                    {offerState.selectedVendors.map((vendor) => (
                      <Box
                        key={vendor.name}
                        style={{
                          display: "flex",
                          justifyContent: "space-between",
                          alignItems: "center",
                          padding: "12px",
                          backgroundColor: "var(--p-surface)",
                          borderRadius: "4px",
                        }}
                      >
                        <Text variant="bodyMd" fontWeight="medium">{vendor.name}</Text>
                        <Box style={{ display: "flex", gap: "8px", alignItems: "center" }}>
                          <Checkbox
                            label="Exclude"
                            checked={excludedItems.vendors.includes(vendor.name)}
                            onChange={() => toggleExcludeItem("vendors", vendor.name)}
                          />
                          <Checkbox
                            label="Notifications"
                            checked={notifications.vendors[vendor.name] || false}
                            onChange={() => toggleNotification("vendors", vendor.name)}
                          />
                          <Button
                            plain
                            onClick={() => removeItem("vendors", vendor.name)}
                            tone="critical"
                          >
                            Remove
                          </Button>
                        </Box>
                      </Box>
                    ))}
                  </Box>
                </Card>
              )}

              {/* Selected Tags */}
              {offerState.selectedTags.length > 0 && (
                <Card sectioned>
                  <Text variant="headingXs" as="h4" fontWeight="semibold">Selected Tags</Text>
                  <Box style={{ display: "flex", flexDirection: "column", gap: "8px" }}>
                    {offerState.selectedTags.map((tag) => (
                      <Box
                        key={tag.name}
                        style={{
                          display: "flex",
                          justifyContent: "space-between",
                          alignItems: "center",
                          padding: "12px",
                          backgroundColor: "var(--p-surface)",
                          borderRadius: "4px",
                        }}
                      >
                        <Text variant="bodyMd" fontWeight="medium">{tag.name}</Text>
                        <Box style={{ display: "flex", gap: "8px", alignItems: "center" }}>
                          <Checkbox
                            label="Exclude"
                            checked={excludedItems.tags.includes(tag.name)}
                            onChange={() => toggleExcludeItem("tags", tag.name)}
                          />
                          <Checkbox
                            label="Notifications"
                            checked={notifications.tags[tag.name] || false}
                            onChange={() => toggleNotification("tags", tag.name)}
                          />
                          <Button
                            plain
                            onClick={() => removeItem("tags", tag.name)}
                            tone="critical"
                          >
                            Remove
                          </Button>
                        </Box>
                      </Box>
                    ))}
                  </Box>
                </Card>
              )}

              {/* Rule Configuration */}
              <Card sectioned>
                <Text variant="headingSm" as="h3" fontWeight="bold">Rule Configuration</Text>
                <FormLayout>
                  <Box style={{ display: "flex", gap: "16px" }}>
                    <Box style={{ flex: 1 }}>
                      <TextField
                        label="Start Date"
                        type="date"
                        value={startDate}
                        onChange={setStartDate}
                        error={errors.startDate}
                        required
                      />
                    </Box>
                    <Box style={{ flex: 1 }}>
                      <TextField
                        label="End Date"
                        type="date"
                        value={endDate}
                        onChange={setEndDate}
                        error={errors.endDate}
                        required
                      />
                    </Box>
                  </Box>
                  <Box paddingBlockEnd="400">
                    <CountrySelector
                      selectedCountry={country}
                      setSelectedCountry={(value) => {
                        setCountry(value);
                        if (errors.country) setErrors((prev) => ({ ...prev, country: "" }));
                      }}
                    />
                    {errors.country && (
                      <Box paddingBlockStart="100">
                        <Text tone="critical">{errors.country}</Text>
                      </Box>
                    )}
                  </Box>
                  <TextField
                    label="Zip Codes (Optional)"
                    value={zipCodes}
                    onChange={(value) => {
                      setZipCodes(value);
                      if (errors.zipCodes) setErrors((prev) => ({ ...prev, zipCodes: "" }));
                    }}
                    placeholder="10001, 10002, 10005-10010, 1002*"
                    helpText="Leave empty for entire country. Enter comma-separated zip codes, ranges, or wildcards"
                    multiline={3}
                    error={errors.zipCodes}
                  />
                  {zipCodes && (
                    <ChoiceList
                      title="Zip Code Rule Type"
                      choices={[
                        { label: "Include only these zip codes", value: "inclusive" },
                        { label: "Exclude these zip codes", value: "exclusive" },
                      ]}
                      selected={zipCodeType}
                      onChange={(selected) => setZipCodeType(selected[0])}
                    />
                  )}
                  <Checkbox
                    label="Pickup Available"
                    checked={pickupAvailable}
                    onChange={(value) => setPickupAvailable(value)}
                  />
                  <TextField
                    label="Local Delivery Options (e.g., Same Day, Next Day)"
                    value={localDelivery}
                    onChange={setLocalDelivery}
                    placeholder="e.g., Same Day Delivery"
                  />
                  <TextField
                    label="Estimated Delivery Time"
                    value={deliveryTime}
                    onChange={setDeliveryTime}
                    error={errors.deliveryTime}
                    placeholder="e.g., 1-2 business days"
                    required
                  />
                  <Select
                    label="Shipping Method"
                    options={shippingMethods}
                    value={shipping}
                    onChange={setShipping}
                  />
                  <TextField
                    label="Event Name (Optional)"
                    value={eventName}
                    onChange={setEventName}
                    placeholder="e.g., Holiday Sale, Black Friday"
                  />
                  <TextField
                    label="Customer Message (Optional)"
                    value={message}
                    onChange={setMessage}
                    multiline={4}
                    placeholder="This message will be shown to customers during checkout"
                  />
                </FormLayout>
              </Card>

              <Box style={{ display: "flex", gap: "16px", justifyContent: "flex-end" }}>
                <Button
                  onClick={() => {
                    setCountry("");
                    setDeliveryTime("");
                    setMessage("");
                    setStartDate("");
                    setEndDate("");
                    setEventName("");
                    setShipping("express");
                    setOfferState({ selectedProducts: [], selectedCollections: [], selectedVendors: [], selectedTags: [] });
                    setExcludedItems({ products: [], collections: [], vendors: [], tags: [] });
                    setNotifications({ products: {}, collections: {}, vendors: {}, tags: {} });
                    setZipCodes("");
                    setZipCodeType("inclusive");
                    setResourceType("product");
                    setSearchQuery("");
                  }}
                >
                  Cancel
                </Button>
                <Button
                  primary
                  onClick={handleSubmit}
                  loading={isSubmitting}
                  disabled={isSubmitting}
                >
                  Create Shipping Rule
                </Button>
              </Box>
            </FormLayout>
          </Card>
        </Layout.Section>
      </Layout>
    </Page>
  );
}


C:\Users\WEB PC\Desktop\web dev mustafa\geo-location\app\routes\api.delivery-country-info.js
import { json } from "@remix-run/node";
import db from "../db.server";

const validCountries = [
  "Afghanistan", "Albania", "Algeria", "Andorra", "Angola", "Argentina", "Armenia", "Australia",
  "Austria", "Azerbaijan", "Bahamas", "Bahrain", "Bangladesh", "Barbados", "Belarus", "Belgium",
  "Belize", "Benin", "Bhutan", "Bolivia", "Bosnia and Herzegovina", "Botswana", "Brazil",
  "Brunei", "Bulgaria", "Burkina Faso", "Burundi", "Cambodia", "Cameroon", "Canada", "Cape Verde",
  "Central African Republic", "Chad", "Chile", "China", "Colombia", "Comoros", "Congo", "Costa Rica",
  "Croatia", "Cuba", "Cyprus", "Czech Republic", "Denmark", "Djibouti", "Dominica",
  "Dominican Republic", "East Timor", "Ecuador", "Egypt", "El Salvador", "Equatorial Guinea",
  "Eritrea", "Estonia", "Eswatini", "Ethiopia", "Fiji", "Finland", "France", "Gabon", "Gambia",
  "Georgia", "Germany", "Ghana", "Greece", "Grenada", "Guatemala", "Guinea", "Guinea-Bissau",
  "Guyana", "Haiti", "Honduras", "Hungary", "Iceland", "India", "Indonesia", "Iran", "Iraq",
  "Ireland", "Israel", "Italy", "Ivory Coast", "Jamaica", "Japan", "Jordan", "Kazakhstan",
  "Kenya", "Kiribati", "Kuwait", "Kyrgyzstan", "Laos", "Latvia", "Lebanon", "Lesotho", "Liberia",
  "Libya", "Liechtenstein", "Lithuania", "Luxembourg", "Madagascar", "Malawi", "Malaysia",
  "Maldives", "Mali", "Malta", "Marshall Islands", "Mauritania", "Mauritius", "Mexico",
  "Micronesia", "Moldova", "Monaco", "Mongolia", "Montenegro", "Morocco", "Mozambique",
  "Myanmar", "Namibia", "Nauru", "Nepal", "Netherlands", "New Zealand", "Nicaragua", "Niger",
  "Nigeria", "North Korea", "North Macedonia", "Norway", "Oman", "Pakistan", "Palau",
  "Palestine", "Panama", "Papua New Guinea", "Paraguay", "Peru", "Philippines", "Poland",
  "Portugal", "Qatar", "Romania", "Russia", "Rwanda", "Saint Kitts and Nevis", "Saint Lucia",
  "Saint Vincent and the Grenadines", "Samoa", "San Marino", "Sao Tome and Principe",
  "Saudi Arabia", "Senegal", "Serbia", "Seychelles", "Sierra Leone", "Singapore", "Slovakia",
  "Slovenia", "Solomon Islands", "Somalia", "South Africa", "South Korea", "South Sudan",
  "Spain", "Sri Lanka", "Sudan", "Suriname", "Sweden", "Switzerland", "Syria", "Taiwan",
  "Tajikistan", "Tanzania", "Thailand", "Togo", "Tonga", "Trinidad and Tobago", "Tunisia",
  "Turkey", "Turkmenistan", "Tuvalu", "Uganda", "Ukraine", "United Arab Emirates",
  "United Kingdom", "United States", "Uruguay", "Uzbekistan", "Vanuatu", "Vatican City",
  "Venezuela", "Vietnam", "Yemen", "Zambia", "Zimbabwe",
];

function normalizeProductId(id) {
  if (!id) return null;
  try {
    return id.toString().replace("gid://shopify/Product/", "");
  } catch (error) {
    console.error("Error normalizing productId:", id, error);
    return null;
  }
}

function formatDateUTC(date) {
  if (!date) return null;
  try {
    return new Date(date).toLocaleDateString("en-GB", {
      year: "numeric",
      month: "short",
      day: "numeric",
      timeZone: "UTC",
    });
  } catch (error) {
    console.error("Error formatting date:", date, error);
    return null;
  }
}

export async function loader({ request }) {
  const headers = {
    "Access-Control-Allow-Origin": "*",
    "Content-Type": "application/json",
  };

  try {
    const url = new URL(request.url);
    const productId = url.searchParams.get("productId");
    const collectionId = url.searchParams.get("collectionId");
    const country = url.searchParams.get("country");

    if (country && !validCountries.includes(country)) {
      return json(
        { error: "Invalid country name", fallback: true },
        { status: 400, headers }
      );
    }

    if (!country && !productId && !collectionId) {
      return json(
        { error: "Country is required for this request", fallback: true },
        { status: 400, headers }
      );
    }

    const today = new Date();
    today.setUTCHours(0, 0, 0, 0);

    const allRules = await db.rule.findMany({
      where: {
        OR: [
          { productId: productId || undefined },
          { collectionId: collectionId || undefined }
        ]
      },
      select: {
        productId: true,
        collectionId: true,
        country: true,
        available: true,
        deliveryTime: true,
        startDate: true,
        endDate: true,
      },
    });

    const countryRules = country
      ? allRules.filter(rule => 
          rule.country && rule.country.toLowerCase() === country.toLowerCase()
        )
      : allRules;

    if (countryRules.some(rule => rule.available === "notavailable")) {
      const notAvailableRule = countryRules.find(rule => rule.available === "notavailable");
      
      return json({
        available: false,
        country: country || "Unknown",
        productId: productId ? normalizeProductId(productId) : null,
        collectionId,
        fallback: false,
        message: country ? `This product is not available in ${country}` : "This product is not available",
        deliveryTime: notAvailableRule?.deliveryTime || null,
        availableFrom: notAvailableRule?.startDate ? formatDateUTC(notAvailableRule.startDate) : null,
        availableUntil: notAvailableRule?.endDate ? formatDateUTC(notAvailableRule.endDate) : null,
      }, { headers });
    }

    const availableRules = countryRules.filter(rule => 
      rule.available === "available" &&
      (!rule.startDate || new Date(rule.startDate) <= today) &&
      (!rule.endDate || new Date(rule.endDate) >= today)
    );

    if (availableRules.length > 0) {
      const availableRule = availableRules[0];
      return json({
        available: true,
        country: country || "Unknown",
        productId: productId ? normalizeProductId(productId) : null,
        collectionId,
        fallback: false,
        message: country ? `This product is available in ${country}` : "This product is available",
        deliveryTime: availableRule.deliveryTime || "Standard shipping",
        availableFrom: availableRule.startDate ? formatDateUTC(availableRule.startDate) : null,
        availableUntil: availableRule.endDate ? formatDateUTC(availableRule.endDate) : null,
      }, { headers });
    }

    return json({
      available: true,
      country: country || "Unknown",
      productId: productId ? normalizeProductId(productId) : null,
      collectionId,
      fallback: false,
      message: country ? `Available for delivery in ${country}` : "Available for delivery",
      deliveryTime: "Standard international shipping",
      availableFrom: null,
      availableUntil: null,
    }, { headers });

  } catch (error) {
    console.error("Loader error:", error);
    return json(
      {
        available: true,
        country: "United States",
        message: "This product is available (fallback)",
        deliveryTime: "3-5 business days",
        fallback: true
      },
      { status: 500, headers }
    );
  }
}


C:\Users\WEB PC\Desktop\web dev mustafa\geo-location\app\routes\api.delivery-info.js
import { json } from "@remix-run/node";
import { PrismaClient } from "@prisma/client";
import nodemailer from "nodemailer";
import dotenv from "dotenv";

dotenv.config();

const prisma = new PrismaClient();
const transporter = nodemailer.createTransport({
  host: process.env.SMTP_HOST,
  port: process.env.SMTP_PORT,
  secure: process.env.SMTP_SECURE === "true",
  auth: {
    user: process.env.SMTP_USER,
    pass: process.env.SMTP_PASS,
  },
});

const normalizeId = (id) => id?.toString().replace(/gid:\/\/shopify\/(Product|Collection)\//, "");

const countryCache = new Map();
const CACHE_TTL = 5 * 60 * 1000;

const formatDatePKT = (date) => {
  const pktDate = new Date(new Date(date).getTime() + 5 * 60 * 60 * 1000);
  return pktDate.toLocaleDateString("en-GB", {
    timeZone: "Asia/Karachi",
    day: "numeric",
    month: "long",
    year: "numeric",
  });
};

async function detectCountry(ip) {
  if (countryCache.has(ip)) {
    const cached = countryCache.get(ip);
    if (Date.now() - cached.timestamp < CACHE_TTL) return cached.country;
    countryCache.delete(ip);
  }

  const fallbackCountry = "Pakistan";
  const ipRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;

  if (!ipRegex.test(ip) && ip !== "8.8.8.8") return fallbackCountry;

  try {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 3000);
    const geoRes = await fetch(`https://ipapi.co/${ip}/json/`, { signal: controller.signal });
    clearTimeout(timeoutId);

    if (geoRes.ok) {
      const geoData = await geoRes.json();
      const country = geoData.country_name || geoData.country || fallbackCountry;
      countryCache.set(ip, { country, timestamp: Date.now() });
      return country;
    }
  } catch {}

  try {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 3000);
    const geoResponse = await fetch(`https://ipwho.is/${ip}`, { signal: controller.signal });
    clearTimeout(timeoutId);

    const geoData = await geoResponse.json();
    if (geoData.success) {
      const country = geoData.country || fallbackCountry;
      countryCache.set(ip, { country, timestamp: Date.now() });
      return country;
    }
  } catch {}

  countryCache.set(ip, { country: fallbackCountry, timestamp: Date.now() });
  return fallbackCountry;
}

const matchesZipCode = (userZipCode, ruleZipCodes, zipCodeType) => {
  if (!ruleZipCodes?.trim()) return true;

  const zipCodeArray = ruleZipCodes.split(",").map((z) => z.trim());
  const userZip = userZipCode.trim();
  let isMatch = false;

  for (const pattern of zipCodeArray) {
    if (pattern.includes("-")) {
      const [start, end] = pattern.split("-").map(Number);
      if (Number(userZip) >= start && Number(userZip) <= end) {
        isMatch = true;
        break;
      }
    } else if (pattern.endsWith("*")) {
      if (userZip.startsWith(pattern.slice(0, -1))) {
        isMatch = true;
        break;
      }
    } else if (pattern === userZip) {
      isMatch = true;
      break;
    }
  }

  return zipCodeType === "inclusive" ? isMatch : !isMatch;
};

export async function loader({ request }) {
  const headers = {
    "Access-Control-Allow-Origin": "*",
    "Content-Type": "application/json",
  };

  try {
    const url = new URL(request.url);
    const productId = normalizeId(url.searchParams.get("productId"));
    const collectionId = normalizeId(url.searchParams.get("collectionId"));
    const selectedCountry = url.searchParams.get("country");
    const zipCode = url.searchParams.get("zipCode");

    if (!productId && !collectionId) {
      return json({ error: "Product ID or Collection ID required", fallback: true }, { status: 400, headers });
    }

    const ip =
      request.headers.get("cf-connecting-ip") ||
      request.headers.get("x-forwarded-for")?.split(",")[0]?.trim() ||
      request.headers.get("x-real-ip") ||
      "8.8.8.8";

    const country = selectedCountry || (await detectCountry(ip));

    const productRule = productId
      ? await prisma.productRule.findFirst({
          where: { productId, excluded: true, rule: { country: { equals: country, mode: "insensitive" } } },
          include: { rule: true },
        })
      : null;

    const collectionRule = collectionId
      ? await prisma.collectionRule.findFirst({
          where: { collectionId, excluded: true, rule: { country: { equals: country, mode: "insensitive" } } },
          include: { rule: true },
        })
      : null;

    if (productRule || collectionRule) {
      const rule = productRule?.rule || collectionRule?.rule;
      const notificationsEnabled = productRule?.notificationsEnabled || collectionRule?.notificationsEnabled || false;

      if (rule && zipCode && matchesZipCode(zipCode, rule.zipCodes, rule.zipCodeType)) {
        return json(
          {
            available: true,
            country,
            productId,
            collectionId,
            zipCode,
            fallback: true,
            message: `Available for delivery in ${country}${zipCode ? ` (zip code: ${zipCode})` : ""}`,
            deliveryTime: "Standard international shipping",
            shippingMethod: null,
            eventName: null,
            availableFrom: null,
            availableUntil: null,
            endDate: null,
            pickupAvailable: false,
            localDelivery: null,
            notificationsEnabled: false,
            debug: { countryDetected: country, ipUsed: ip, zipCode },
          },
          { headers }
        );
      }

      return json(
        {
          available: false,
          country,
          productId,
          collectionId,
          zipCode,
          fallback: false,
          message: notificationsEnabled
            ? `This ${productId ? "product" : "collection"} is not available in ${country}${zipCode ? ` (zip code: ${zipCode})` : ""}, but you can sign up for notifications.`
            : `This ${productId ? "product" : "collection"} is not available in ${country}${zipCode ? ` (zip code: ${zipCode})` : ""} and notifications are off.`,
          deliveryTime: null,
          shippingMethod: null,
          eventName: null,
          availableFrom: null,
          availableUntil: null,
          endDate: null,
          pickupAvailable: false,
          localDelivery: null,
          estimatedDeliveryDate: null,
          notificationsEnabled,
          debug: { countryDetected: country, ipUsed: ip, zipCode },
        },
        { headers }
      );
    }

    const rules = await prisma.rule.findMany({
      where: {
        OR: [
          productId ? { productRules: { some: { productId } } } : {},
          collectionId ? { collectionRules: { some: { collectionId } } } : {},
        ],
        country: { equals: country, mode: "insensitive" },
      },
      include: {
        productRules: { where: productId ? { productId } : {} },
        collectionRules: { where: collectionId ? { collectionId } : {} },
      },
    });

    const now = new Date();
    const nowPKT = new Date(now.getTime() + 5 * 60 * 60 * 1000);
    const nowPKTDate = nowPKT.toISOString().split("T")[0];

    const validRules = rules.filter((rule) => {
      const startDate = rule.startDate ? new Date(rule.startDate) : null;
      const endDate = rule.endDate ? new Date(rule.endDate) : null;
      if (startDate) startDate.setUTCHours(0, 0, 0, 0);
      if (endDate) endDate.setUTCHours(23, 59, 59, 999);

      const startDateStr = startDate ? startDate.toISOString().split("T")[0] : null;
      const isBeforeEnd = !endDate || now <= endDate;
      const isAfterStart = !startDate || nowPKTDate >= startDateStr;

      return isBeforeEnd && isAfterStart && (!rule.zipCodes || !zipCode || matchesZipCode(zipCode, rule.zipCodes, rule.zipCodeType));
    });

    if (validRules.length > 0) {
      const rule = validRules[0];
      const startDate = rule.startDate ? new Date(rule.startDate) : null;
      const endDate = rule.endDate ? new Date(rule.endDate) : null;
      const deliveryDays = rule.deliveryTime?.match(/\d+/)?.[0] || 3;
      const estimatedDate = new Date(now.getTime() + deliveryDays * 24 * 60 * 60 * 1000);
      const notificationsEnabled = rule.productRules[0]?.notificationsEnabled || rule.collectionRules[0]?.notificationsEnabled || false;

      return json(
        {
          available: true,
          country,
          productId,
          collectionId,
          zipCode,
          fallback: false,
          message: rule.message || `Available for delivery in ${country}${zipCode ? ` (zip code: ${zipCode})` : ""}`,
          deliveryTime: rule.deliveryTime || "Standard shipping",
          shippingMethod: rule.shippingMethod || null,
          eventName: rule.eventName || null,
          availableFrom: startDate ? formatDatePKT(startDate) : null,
          availableUntil: endDate ? formatDatePKT(endDate) : null,
          endDate: endDate ? endDate.toISOString() : null,
          pickupAvailable: rule.pickupAvailable,
          localDelivery: rule.localDelivery,
          notificationsEnabled,
          debug: {
            countryDetected: country,
            ipUsed: ip,
            ruleId: rule.id,
            startDate: startDate?.toISOString(),
            endDate: endDate?.toISOString(),
            zipCode,
          },
        },
        { headers }
      );
    }

    if (zipCode) {
      const zipCodeRules = await prisma.rule.findMany({
        where: {
          OR: [
            productId ? { productRules: { some: { productId } } } : {},
            collectionId ? { collectionRules: { some: { collectionId } } } : {},
          ],
          country: { equals: country, mode: "insensitive" },
          zipCodes: { not: null },
        },
      });

      if (zipCodeRules.length > 0) {
        return json(
          {
            available: false,
            country,
            productId,
            collectionId,
            zipCode,
            fallback: false,
            message: `This ${productId ? "product" : "collection"} is not available in ${country} (zip code: ${zipCode}).`,
            deliveryTime: null,
            shippingMethod: null,
            eventName: null,
            availableFrom: null,
            availableUntil: null,
            endDate: null,
            pickupAvailable: false,
            localDelivery: null,
            estimatedDeliveryDate: null,
            notificationsEnabled: false,
            debug: { countryDetected: country, ipUsed: ip, zipCode, totalRules: zipCodeRules.length },
          },
          { headers }
        );
      }
    }

    const estimatedDate = new Date(now.getTime() + 3 * 24 * 60 * 60 * 1000);
    return json(
      {
        available: true,
        country,
        productId,
        collectionId,
        zipCode,
        fallback: true,
        message: `Available for delivery in ${country}${zipCode ? ` (zip code: ${zipCode})` : ""}`,
        deliveryTime: "Standard international shipping",
        shippingMethod: null,
        eventName: null,
        availableFrom: null,
        availableUntil: null,
        endDate: null,
        pickupAvailable: false,
        localDelivery: null,
        notificationsEnabled: false,
        debug: { countryDetected: country, ipUsed: ip, totalRules: rules.length, zipCode },
      },
      { headers }
    );
  } catch (error) {
    console.error("API Error:", error);
    const estimatedDate = new Date(Date.now() + 3 * 24 * 60 * 60 * 1000);
    return json(
      {
        available: true,
        country: "Pakistan",
        productId: normalizeId(new URL(request.url).searchParams.get("productId")),
        collectionId: normalizeId(new URL(request.url).searchParams.get("collectionId")),
        zipCode: new URL(request.url).searchParams.get("zipCode") || null,
        message: `This product is available (fallback)${zipCode ? ` (zip code: ${zipCode})` : ""}`,
        deliveryTime: "Standard international shipping",
        shippingMethod: null,
        eventName: null,
        availableFrom: null,
        availableUntil: null,
        endDate: null,
        pickupAvailable: false,
        localDelivery: null,
        notificationsEnabled: false,
        fallback: true,
        debug: { error: error.message, zipCode },
      },
      { status: 500, headers }
    );
  }
}

export async function action({ request }) {
  const headers = {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Methods": "GET, POST, OPTIONS",
    "Access-Control-Allow-Headers": "Content-Type",
    "Content-Type": "application/json",
  };

  if (request.method === "OPTIONS") return new Response(null, { status: 204, headers });

  try {
    const formData = await request.formData();
    if (formData.get("actionType") === "notify") {
      const email = formData.get("email");
      const productId = formData.get("productId");
      const collectionId = formData.get("collectionId");
      const country = formData.get("country");

      if (!email || !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
        return json({ error: "Valid email is required" }, { status: 400, headers });
      }

      const productRule = productId
        ? await prisma.productRule.findFirst({
            where: { productId, notificationsEnabled: true, rule: { country: { equals: country, mode: "insensitive" } } },
            include: { rule: true },
          })
        : null;

      const collectionRule = collectionId
        ? await prisma.collectionRule.findFirst({
            where: { collectionId, notificationsEnabled: true, rule: { country: { equals: country, mode: "insensitive" } } },
            include: { rule: true },
          })
        : null;

      const rule = productRule?.rule || collectionRule?.rule;
      if (!rule) {
        return json({ error: "Notifications not enabled for this product in your country" }, { status: 403, headers });
      }

      await prisma.notificationSignup.create({
        data: { email, productId, collectionId, country },
      });

      try {
        await transporter.sendMail({
          from: `"Test Store 0012" <${process.env.SMTP_USER}>`,
          to: email,
          subject: "Notification Signup Confirmation",
          html: `<h1>Thank You for Signing Up!</h1>
                 <p>You will be notified when the product is available in ${country}.</p>
                 <p>Product ID: ${productId || "N/A"}</p>
                 <p>Collection ID: ${collectionId || "N/A"}</p>`,
        });
        return json({ success: true, message: "You'll be notified when available!" }, { headers });
      } catch (err) {
        console.error("Email failed:", err);
        return json(
          { success: false, message: "Unable to send email. Please use a verified email or try later." },
          { headers }
        );
      }
    }

    return json(null, { headers });
  } catch (error) {
    console.error("Action error:", error);
    return json({ error: "Server error, please try again later" }, { status: 500, headers });
  }
}



C:\Users\WEB PC\Desktop\web dev mustafa\geo-location\app\.env
# Add these missing variables:
SHOPIFY_API_KEY=***9e066822aa12172ceadeaa78e446a1b1***
SHOPIFY_API_SECRET=***4d3bbcd6f19b9691a4c191dc9dd8c08b***
SCOPES=read_products,write_products,read_orders,read_customers,write_customers
SHOPIFY_APP_URL=https://your-ngrok-url.ngrok-free.app
# Your existing variables are good
DATABASE_URL="postgresql://postgres:12345@localhost:5432/database_name"
ALLOWED_ORIGINS=https://mustafadevstore-com.myshopify.com
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_SECURE=false
SMTP_USER=your-email@gmail.com
SMTP_PASS=your-app-password